# 建议


# 规则

## EXP30. 不要依赖序列点之间的求值顺序。

**示例1**
```c
void func(int i, int *b) 
{
    int a = i + b[++i];
    printf("%d, %d", a, i);
}
 
int main(void)
{
    int b[5]={1,2,3,4,5};
    func(1,b);
}    
```
程序无法安全地依赖序列点之间操作数的求值顺序，话句话说，在连续的“序列点”之间，仅能通过表达式修改一次对象的值。
在这个不合规代码示例中，由于没有中间序列点， i 被求值了两次，所以表达式的行为是未定义的。
因此函数的打印数值是不确定的。

> 所谓序列点的概念，C 语言定义如下^[microsoft learn]：
> 1. **逻辑“与”运算符 (&&) 的左操作数**。 完全计算逻辑“与”运算符的左操作数，并在继续之前完成所有副作用。 如果左操作数的计算结果为 false (0)，则不计算另一个操作数。
> 2. **逻辑“或”运算符 (||) 的左操作数**。 完全计算逻辑“或”运算符的左操作数，并在继续之前完成所有副作用。 如果左操作数的计算结果为 true（非零），则不计算另一个操作数。
> 3. **逗号运算符的左操作数**。 完全计算逗号运算符的左操作数，并在继续之前完成所有副作用。 始终计算逗号运算符的两个操作数。 请注意，函数调用中的逗号运算符不保证计算顺序。
> 4. **函数调用运算符**。 计算函数的所有参数，并在输入函数前完成所有副作用。 未指定参数之间的计算顺序。
> 5. **条件运算符的第一个操作数**。 完全计算条件运算符的第一个操作数，并在继续之前完成所有副作用。
> 6. **完全初始化表达式的末尾**（即，不是一个表达式的一部分的另一个表达式，如声明语句中的初始化的末尾）。
> 7. **表达式语句中的表达式**。 表达式语句由可选表达式后跟分号 (; ) 组成。 为其副作用计算该表达式，并且此计算后面有一个序列点。
> 8. **选择语句（if 或 switch）中的控制表达式**。 完全计算该表达式，并在执行依赖于选择的代码之前完成所有副作用。
> 9. **while 或 do 语句的控制表达式**。 在执行 while 或 do 循环的下一个迭代中的任何语句前，完全计算表达式，并且完成所有副作用。
> 10. **for 语句的所有三个表达式**。 在执行 for 循环的下一个迭代中的任何语句前，完全计算表达式，并且完成所有副作用。
> 11. **return 语句中的表达式**。 完全计算该表达式，并在控制返回调用函数之前完成所有副作用。

# REF

1. ![microsoft learn](https://learn.microsoft.com/zh-cn/cpp/c-language/c-sequence-points?view=msvc-170)
